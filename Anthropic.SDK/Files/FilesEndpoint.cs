using System;
using System.Collections.Generic;
using System.IO;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading;
using System.Threading.Tasks;

namespace Anthropic.SDK.Files
{
    /// <summary>
    /// Files endpoint for managing Claude-generated files.
    /// The Files API allows you to download, list, and manage files generated by Claude during conversations.
    /// </summary>
    public class FilesEndpoint : EndpointBase
    {
        /// <summary>
        /// Constructor of the api endpoint. Rather than instantiating this yourself, access it through an instance of <see cref="AnthropicClient"/> as <see cref="AnthropicClient.Files"/>.
        /// </summary>
        /// <param name="client"></param>
        internal FilesEndpoint(AnthropicClient client) : base(client) { }

        protected override string Endpoint => "files";

        /// <summary>
        /// Lists all files in the organization. Supports pagination using before_id/after_id cursors.
        /// </summary>
        /// <param name="beforeId">Only return files with IDs alphabetically before this file ID.</param>
        /// <param name="afterId">Only return files with IDs alphabetically after this file ID.</param>
        /// <param name="limit">Number of files to return per page (1-1000, default 20).</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>A paginated list of file metadata objects.</returns>
        public async Task<FileListResponse> ListFilesAsync(
            string beforeId = null,
            string afterId = null,
            int limit = 20,
            CancellationToken cancellationToken = default)
        {
            if (limit < 1 || limit > 1000)
            {
                throw new ArgumentOutOfRangeException(nameof(limit), "Limit must be between 1 and 1000.");
            }

            var queryParams = new List<string> { $"limit={limit}" };
            if (!string.IsNullOrEmpty(beforeId))
                queryParams.Add($"before_id={beforeId}");
            if (!string.IsNullOrEmpty(afterId))
                queryParams.Add($"after_id={afterId}");

            var queryString = "?" + string.Join("&", queryParams);
            return await HttpRequestSimple<FileListResponse>($"{Endpoint}{queryString}", HttpMethod.Get, null, cancellationToken);
        }

        /// <summary>
        /// Retrieves metadata for a specific file by its ID.
        /// </summary>
        /// <param name="fileId">The ID of the file to retrieve metadata for.</param>
        /// <param name="cancellationToken">Optional cancellation token.</param>
        /// <returns>The file metadata object.</returns>
        /// <exception cref="ArgumentNullException">Thrown when fileId is null or empty.</exception>
        public async Task<FileMetadata> GetFileMetadataAsync(
            string fileId,
            CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrWhiteSpace(fileId))
            {
                throw new ArgumentNullException(nameof(fileId), "File ID cannot be null or empty.");
            }

            return await HttpRequestSimple<FileMetadata>($"{Endpoint}/{fileId}", HttpMethod.Get, null, cancellationToken);
        }

        /// <summary>
        /// Uploads a file to Claude for use in conversations.
        /// </summary>
        /// <param name="filePath">Path to the file to upload.</param>
        /// <param name="mimeType">Optional MIME type of the file. If not provided, will be inferred from the file extension.</param>
        /// <param name="ctx">Cancellation token.</param>
        /// <returns>Metadata about the uploaded file.</returns>
        /// <exception cref="ArgumentException">Thrown when filePath is null, empty, or the file doesn't exist.</exception>
        public async Task<FileMetadata> UploadFileAsync(string filePath, string mimeType = null, CancellationToken ctx = default)
        {
            if (string.IsNullOrWhiteSpace(filePath))
            {
                throw new ArgumentException("File path cannot be null or empty.", nameof(filePath));
            }

            if (!File.Exists(filePath))
            {
                throw new ArgumentException($"File not found: {filePath}", nameof(filePath));
            }

            var fileName = Path.GetFileName(filePath);
#if NET6_0_OR_GREATER
            var fileBytes = await File.ReadAllBytesAsync(filePath, ctx).ConfigureAwait(false);
#else
            var fileBytes = File.ReadAllBytes(filePath);
#endif

            // Infer MIME type if not provided
            if (string.IsNullOrWhiteSpace(mimeType))
            {
                mimeType = GetMimeType(filePath);
            }

            return await UploadFileBytesAsync(fileBytes, fileName, mimeType, ctx).ConfigureAwait(false);
        }

        /// <summary>
        /// Uploads a file from a byte array to Claude for use in conversations.
        /// </summary>
        /// <param name="fileBytes">The file content as a byte array.</param>
        /// <param name="fileName">The name of the file.</param>
        /// <param name="mimeType">MIME type of the file.</param>
        /// <param name="ctx">Cancellation token.</param>
        /// <returns>Metadata about the uploaded file.</returns>
        /// <exception cref="ArgumentException">Thrown when parameters are invalid.</exception>
        /// <exception cref="ArgumentNullException">Thrown when fileBytes is null.</exception>
        public async Task<FileMetadata> UploadFileBytesAsync(byte[] fileBytes, string fileName, string mimeType, CancellationToken ctx = default)
        {
            if (fileBytes == null)
            {
                throw new ArgumentNullException(nameof(fileBytes));
            }

            if (string.IsNullOrWhiteSpace(fileName))
            {
                throw new ArgumentException("File name cannot be null or empty.", nameof(fileName));
            }

            if (string.IsNullOrWhiteSpace(mimeType))
            {
                throw new ArgumentException("MIME type cannot be null or empty.", nameof(mimeType));
            }

            using var content = new MultipartFormDataContent();
            var fileContent = new ByteArrayContent(fileBytes);
            fileContent.Headers.ContentType = new MediaTypeHeaderValue(mimeType);
            content.Add(fileContent, "file", fileName);

            var result = await HttpRequestSimple<FileMetadata>(Url, HttpMethod.Post, content, ctx).ConfigureAwait(false);

            return result;
        }

        /// <summary>
        /// Uploads a file from a stream to Claude for use in conversations.
        /// </summary>
        /// <param name="fileStream">The file content as a stream.</param>
        /// <param name="fileName">The name of the file.</param>
        /// <param name="mimeType">MIME type of the file.</param>
        /// <param name="ctx">Cancellation token.</param>
        /// <returns>Metadata about the uploaded file.</returns>
        /// <exception cref="ArgumentException">Thrown when parameters are invalid.</exception>
        /// <exception cref="ArgumentNullException">Thrown when fileStream is null.</exception>
        public async Task<FileMetadata> UploadFileStreamAsync(Stream fileStream, string fileName, string mimeType, CancellationToken ctx = default)
        {
            if (fileStream == null)
            {
                throw new ArgumentNullException(nameof(fileStream));
            }

            if (string.IsNullOrWhiteSpace(fileName))
            {
                throw new ArgumentException("File name cannot be null or empty.", nameof(fileName));
            }

            if (string.IsNullOrWhiteSpace(mimeType))
            {
                throw new ArgumentException("MIME type cannot be null or empty.", nameof(mimeType));
            }

            using var content = new MultipartFormDataContent();
            var streamContent = new StreamContent(fileStream);
            streamContent.Headers.ContentType = new MediaTypeHeaderValue(mimeType);
            content.Add(streamContent, "file", fileName);

            var result = await HttpRequestSimple<FileMetadata>(Url, HttpMethod.Post, content, ctx).ConfigureAwait(false);

            return result;
        }

        /// <summary>
        /// Downloads the contents of a Claude-generated file.
        /// </summary>
        /// <param name="fileId">ID of the file to download.</param>
        /// <param name="outputPath">Optional path to save the file. If not provided, returns the file content as a byte array.</param>
        /// <param name="ctx">Cancellation token.</param>
        /// <returns>The file content as a byte array if outputPath is not provided.</returns>
        /// <exception cref="ArgumentException">Thrown when fileId is null or empty.</exception>
        public async Task<byte[]> DownloadFileAsync(string fileId, string outputPath = null, CancellationToken ctx = default)
        {
            if (string.IsNullOrWhiteSpace(fileId))
            {
                throw new ArgumentException("File ID cannot be null or empty.", nameof(fileId));
            }

            var url = $"{Url}/{fileId}/content";
            var response = await HttpRequestRaw(url, HttpMethod.Get, null, streaming: false, ctx).ConfigureAwait(false);

#if NET6_0_OR_GREATER
            var content = await response.Content.ReadAsByteArrayAsync(ctx).ConfigureAwait(false);
#else
            var content = await response.Content.ReadAsByteArrayAsync().ConfigureAwait(false);
#endif

            if (!string.IsNullOrWhiteSpace(outputPath))
            {
                // Ensure the directory exists
                var directory = Path.GetDirectoryName(outputPath);
                if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                }

#if NET6_0_OR_GREATER
                await File.WriteAllBytesAsync(outputPath, content, ctx).ConfigureAwait(false);
#else
                File.WriteAllBytes(outputPath, content);
#endif
            }

            return content;
        }

        /// <summary>
        /// Downloads the contents of a Claude-generated file and writes it to a stream.
        /// </summary>
        /// <param name="fileId">ID of the file to download.</param>
        /// <param name="outputStream">The stream to write the file content to.</param>
        /// <param name="ctx">Cancellation token.</param>
        /// <exception cref="ArgumentException">Thrown when fileId is null or empty.</exception>
        /// <exception cref="ArgumentNullException">Thrown when outputStream is null.</exception>
        public async Task DownloadFileToStreamAsync(string fileId, Stream outputStream, CancellationToken ctx = default)
        {
            if (string.IsNullOrWhiteSpace(fileId))
            {
                throw new ArgumentException("File ID cannot be null or empty.", nameof(fileId));
            }

            if (outputStream == null)
            {
                throw new ArgumentNullException(nameof(outputStream));
            }

            var url = $"{Url}/{fileId}/content";
            var response = await HttpRequestRaw(url, HttpMethod.Get, null, streaming: true, ctx).ConfigureAwait(false);

#if NET6_0_OR_GREATER
            await using var stream = await response.Content.ReadAsStreamAsync(ctx).ConfigureAwait(false);
            await stream.CopyToAsync(outputStream, 81920, ctx).ConfigureAwait(false);
#else
            using var stream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false);
            await stream.CopyToAsync(outputStream, 81920, ctx).ConfigureAwait(false);
#endif
        }

        /// <summary>
        /// Gets the MIME type based on file extension.
        /// </summary>
        private static string GetMimeType(string filePath)
        {
            var extension = Path.GetExtension(filePath).ToLowerInvariant();
            return extension switch
            {
                ".pdf" => "application/pdf",
                ".txt" => "text/plain",
                ".html" => "text/html",
                ".htm" => "text/html",
                ".json" => "application/json",
                ".xml" => "application/xml",
                ".csv" => "text/csv",
                ".doc" => "application/msword",
                ".docx" => "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                ".xls" => "application/vnd.ms-excel",
                ".xlsx" => "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                ".ppt" => "application/vnd.ms-powerpoint",
                ".pptx" => "application/vnd.openxmlformats-officedocument.presentationml.presentation",
                ".jpg" => "image/jpeg",
                ".jpeg" => "image/jpeg",
                ".png" => "image/png",
                ".gif" => "image/gif",
                ".bmp" => "image/bmp",
                ".svg" => "image/svg+xml",
                ".webp" => "image/webp",
                ".zip" => "application/zip",
                ".gz" => "application/gzip",
                ".tar" => "application/x-tar",
                ".md" => "text/markdown",
                ".rtf" => "application/rtf",
                _ => "application/octet-stream"
            };
        }
    }
}
